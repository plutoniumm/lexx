{
  "name": "Go",
  "color": "#6ce",
  "template": "static",
  "type": "files",
  "files": {
    "api.js": "// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n( () => {\n\tif ( typeof global !== \"undefined\" ) {\n\t\t// global already exists\n\t} else if ( typeof window !== \"undefined\" ) {\n\t\twindow.global = window;\n\t} else if ( typeof self !== \"undefined\" ) {\n\t\tself.global = self;\n\t} else {\n\t\tthrow new Error( \"cannot export Go (neither global, window nor self is defined)\" );\n\t}\n\n\tconst encoder = new TextEncoder( 'utf-8' );\n\tconst decoder = new TextDecoder( 'utf-8' );\n\n\tconst filesystem = {};\n\n\tlet workingDirectory = '/';\n\n\tlet absPath = ( path ) => {\n\t\tif ( path[ 0 ] == '/' ) {\n\t\t\treturn path;\n\t\t}\n\t\treturn workingDirectory + path.replace( /^\\.\\/?/, '' );\n\t};\n\n\tglobal.readFS = ( path ) => filesystem[ absPath( path ) ];\n\tglobal.writeFS = ( path, content ) => {\n\t\tif ( typeof content === 'string' ) {\n\t\t\tfilesystem[ absPath( path ) ] = encoder.encode( content );\n\t\t} else {\n\t\t\tfilesystem[ absPath( path ) ] = content;\n\t\t}\n\t};\n\tglobal.goStdout = ( buf ) => { };\n\tglobal.goStderr = ( buf ) => { };\n\n\tconst openFiles = new Map();\n\tlet nextFd = 1000;\n\n\tlet stat = ( path, callback ) => {\n\t\tlet mode = 0;\n\t\tif ( path === '/' ) {\n\t\t\tmode |= 0x80000000;\n\t\t} else if ( filesystem[ path ] === undefined ) {\n\t\t\tconst err = new Error( 'no such file' );\n\t\t\terr.code = 'ENOENT';\n\t\t\tcallback( err );\n\t\t\treturn;\n\t\t}\n\t\tcallback( null, {\n\t\t\tmode,\n\t\t\tdev: 0,\n\t\t\tino: 0,\n\t\t\tnlink: 0,\n\t\t\tuid: 0,\n\t\t\tgid: 0,\n\t\t\trdev: 0,\n\t\t\tsize: 0,\n\t\t\tblksize: 0,\n\t\t\tblocks: 0,\n\t\t\tatimeMs: 0,\n\t\t\tmtimeMs: 0,\n\t\t\tctimeMs: 0,\n\t\t\tisDirectory: () => !!( mode & 0x80000000 ),\n\t\t} );\n\t};\n\n\tconst constants = {\n\t\tO_WRONLY: 1 << 0,\n\t\tO_RDWR: 1 << 1,\n\t\tO_CREAT: 1 << 2,\n\t\tO_TRUNC: 1 << 3,\n\t\tO_APPEND: 1 << 4,\n\t\tO_EXCL: 1 << 5,\n\t};\n\n\tlet outputBuf = \"\";\n\tglobal.fs = {\n\t\tconstants,\n\t\twriteSync ( fd, buf ) {\n\t\t\tif ( fd === 1 ) {\n\t\t\t\tglobal.goStdout( buf );\n\t\t\t} else if ( fd === 2 ) {\n\t\t\t\tglobal.goStderr( buf );\n\t\t\t} else {\n\t\t\t\tconst file = openFiles[ fd ];\n\t\t\t\tconst source = filesystem[ file.path ];\n\t\t\t\tlet destLength = source.length + buf.length;\n\t\t\t\tif ( file.offset < source.length ) {\n\t\t\t\t\tdestLength = file.offset + buf.length;\n\t\t\t\t\tif ( destLength < source.length ) {\n\t\t\t\t\t\tdestLength = source.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst dest = new Uint8Array( destLength );\n\t\t\t\tfor ( let i = 0;i < source.length;++i ) {\n\t\t\t\t\tdest[ i ] = source[ i ];\n\t\t\t\t}\n\t\t\t\tfor ( let i = 0;i < buf.length;++i ) {\n\t\t\t\t\tdest[ file.offset + i ] = buf[ i ];\n\t\t\t\t}\n\t\t\t\topenFiles[ fd ].offset += buf.length;\n\t\t\t\tfilesystem[ file.path ] = dest;\n\t\t\t}\n\t\t},\n\t\twrite ( fd, buf, offset, length, position, callback ) {\n\t\t\tif ( offset !== 0 || length !== buf.length ) {\n\t\t\t\tthrow new Error( 'write not fully implemented: ' + offset + ', ' + length + '/' + buf.length );\n\t\t\t}\n\t\t\tif ( position !== null ) {\n\t\t\t\topenFiles[ fd ].offset = position;\n\t\t\t}\n\t\t\tthis.writeSync( fd, buf );\n\t\t\tcallback( null, length );\n\t\t},\n\t\topen ( path, flags, mode, callback ) {\n\t\t\t// console.log( 'open(' + path + ', ' + mode + ')' );\n\t\t\tpath = absPath( path );\n\t\t\tif ( !filesystem[ path ] ) {\n\t\t\t\tif ( flags & constants.O_CREAT ) {\n\t\t\t\t\tfilesystem[ path ] = new Uint8Array( 0 );\n\t\t\t\t} else {\n\t\t\t\t\tconst err = new Error( 'no such file' );\n\t\t\t\t\terr.code = 'ENOENT';\n\t\t\t\t\tcallback( err );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( flags & constants.O_TRUNC ) {\n\t\t\t\tfilesystem[ path ] = new Uint8Array( 0 );\n\t\t\t}\n\t\t\tconst fd = nextFd++;\n\t\t\topenFiles[ fd ] = {\n\t\t\t\toffset: 0,\n\t\t\t\tpath,\n\t\t\t};\n\t\t\tcallback( null, fd );\n\t\t},\n\t\tread ( fd, buffer, offset, length, position, callback ) {\n\t\t\tif ( offset !== 0 ) {\n\t\t\t\tthrow new Error( 'read not fully implemented: ' + offset );\n\t\t\t}\n\t\t\tif ( position !== null ) {\n\t\t\t\topenFiles[ fd ].offset = position;\n\t\t\t}\n\t\t\tconst file = openFiles[ fd ];\n\t\t\tconst source = filesystem[ file.path ];\n\t\t\tlet n = length;\n\t\t\tif ( file.offset + length > source.length ) {\n\t\t\t\tn = source.length - file.offset;\n\t\t\t}\n\t\t\tfor ( let i = 0;i < n;++i ) {\n\t\t\t\tbuffer[ i ] = source[ file.offset + i ];\n\t\t\t}\n\t\t\topenFiles[ fd ].offset += n;\n\t\t\tcallback( null, n );\n\t\t},\n\t\tclose ( fd, callback ) {\n\t\t\t// console.log( 'close(' + fd + ')' );\n\t\t\topenFiles.delete( fd );\n\t\t\tcallback( null );\n\t\t},\n\t\tfsync ( fd, callback ) {\n\t\t\tcallback( null );\n\t\t},\n\t\tunlink ( path, callback ) {\n\t\t\t// console.log( 'unlink(' + path + ')' );\n\t\t\tcallback( null );\n\t\t},\n\t\tfstat ( fd, callback ) {\n\t\t\t// console.log( 'fstat(' + fd + ')' );\n\t\t\tstat( openFiles[ fd ].path, callback );\n\t\t},\n\t\tstat ( path, callback ) {\n\t\t\t// console.log( 'stat(' + path + ')' );\n\t\t\tstat( absPath( path ), callback );\n\t\t},\n\t\tlstat ( path, callback ) {\n\t\t\t// console.log( 'lstat(' + path + ')' );\n\t\t\tstat( absPath( path ), callback );\n\t\t},\n\t\tfchmod ( fd, mode, callback ) {\n\t\t\t// console.log( 'fchmod(' + fd + ', ' + mode + ')' );\n\t\t\tcallback( null );\n\t\t},\n\t};\n\n\tglobal.process = {\n\t\tcwd () {\n\t\t\t// console.log( 'cwd()' );\n\t\t\treturn workingDirectory;\n\t\t},\n\t};\n\n\tglobal.Go = class {\n\t\tconstructor () {\n\t\t\tthis.argv = [ \"js\" ];\n\t\t\tthis.env = {};\n\t\t\tthis.exit = ( code ) => {\n\t\t\t\tif ( code !== 0 ) {\n\t\t\t\t\tconsole.warn( \"exit code:\", code );\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._exitPromise = new Promise( ( resolve ) => {\n\t\t\t\tthis._resolveExitPromise = resolve;\n\t\t\t} );\n\t\t\tthis._pendingEvent = null;\n\t\t\tthis._scheduledTimeouts = new Map();\n\t\t\tthis._nextCallbackTimeoutID = 1;\n\n\t\t\tconst mem = () => {\n\t\t\t\t// The buffer may change when requesting more memory.\n\t\t\t\treturn new DataView( this._inst.exports.mem.buffer );\n\t\t\t}\n\n\t\t\tconst setInt64 = ( addr, v ) => {\n\t\t\t\tmem().setUint32( addr + 0, v, true );\n\t\t\t\tmem().setUint32( addr + 4, Math.floor( v / 4294967296 ), true );\n\t\t\t}\n\n\t\t\tconst getInt64 = ( addr ) => {\n\t\t\t\tconst low = mem().getUint32( addr + 0, true );\n\t\t\t\tconst high = mem().getInt32( addr + 4, true );\n\t\t\t\treturn low + high * 4294967296;\n\t\t\t}\n\n\t\t\tconst loadValue = ( addr ) => {\n\t\t\t\tconst f = mem().getFloat64( addr, true );\n\t\t\t\tif ( f === 0 ) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tif ( !isNaN( f ) ) {\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\n\t\t\t\tconst id = mem().getUint32( addr, true );\n\t\t\t\treturn this._values[ id ];\n\t\t\t}\n\n\t\t\tconst storeValue = ( addr, v ) => {\n\t\t\t\tconst nanHead = 0x7FF80000;\n\n\t\t\t\tif ( typeof v === \"number\" ) {\n\t\t\t\t\tif ( isNaN( v ) ) {\n\t\t\t\t\t\tmem().setUint32( addr + 4, nanHead, true );\n\t\t\t\t\t\tmem().setUint32( addr, 0, true );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif ( v === 0 ) {\n\t\t\t\t\t\tmem().setUint32( addr + 4, nanHead, true );\n\t\t\t\t\t\tmem().setUint32( addr, 1, true );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tmem().setFloat64( addr, v, true );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tswitch ( v ) {\n\t\t\t\t\tcase undefined:\n\t\t\t\t\t\tmem().setFloat64( addr, 0, true );\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase null:\n\t\t\t\t\t\tmem().setUint32( addr + 4, nanHead, true );\n\t\t\t\t\t\tmem().setUint32( addr, 2, true );\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase true:\n\t\t\t\t\t\tmem().setUint32( addr + 4, nanHead, true );\n\t\t\t\t\t\tmem().setUint32( addr, 3, true );\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase false:\n\t\t\t\t\t\tmem().setUint32( addr + 4, nanHead, true );\n\t\t\t\t\t\tmem().setUint32( addr, 4, true );\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlet ref = this._refs.get( v );\n\t\t\t\tif ( ref === undefined ) {\n\t\t\t\t\tref = this._values.length;\n\t\t\t\t\tthis._values.push( v );\n\t\t\t\t\tthis._refs.set( v, ref );\n\t\t\t\t}\n\t\t\t\tlet typeFlag = 0;\n\t\t\t\tswitch ( typeof v ) {\n\t\t\t\t\tcase \"string\":\n\t\t\t\t\t\ttypeFlag = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"symbol\":\n\t\t\t\t\t\ttypeFlag = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"function\":\n\t\t\t\t\t\ttypeFlag = 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmem().setUint32( addr + 4, nanHead | typeFlag, true );\n\t\t\t\tmem().setUint32( addr, ref, true );\n\t\t\t}\n\n\t\t\tconst loadSlice = ( addr ) => {\n\t\t\t\tconst array = getInt64( addr + 0 );\n\t\t\t\tconst len = getInt64( addr + 8 );\n\t\t\t\treturn new Uint8Array( this._inst.exports.mem.buffer, array, len );\n\t\t\t}\n\n\t\t\tconst loadSliceOfValues = ( addr ) => {\n\t\t\t\tconst array = getInt64( addr + 0 );\n\t\t\t\tconst len = getInt64( addr + 8 );\n\t\t\t\tconst a = new Array( len );\n\t\t\t\tfor ( let i = 0;i < len;i++ ) {\n\t\t\t\t\ta[ i ] = loadValue( array + i * 8 );\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t}\n\n\t\t\tconst loadString = ( addr ) => {\n\t\t\t\tconst saddr = getInt64( addr + 0 );\n\t\t\t\tconst len = getInt64( addr + 8 );\n\t\t\t\treturn decoder.decode( new DataView( this._inst.exports.mem.buffer, saddr, len ) );\n\t\t\t}\n\n\t\t\tconst timeOrigin = Date.now() - performance.now();\n\t\t\tthis.importObject = {\n\t\t\t\tgo: {\n\t\t\t\t\t// Go's SP does not change as long as no Go code is running. Some operations (e.g. calls, getters and setters)\n\t\t\t\t\t// may synchronously trigger a Go event handler. This makes Go code get executed in the middle of the imported\n\t\t\t\t\t// function. A goroutine can switch to a new stack if the current stack is too small (see morestack function).\n\t\t\t\t\t// This changes the SP, thus we have to update the SP used by the imported function.\n\n\t\t\t\t\t// func wasmExit(code int32)\n\t\t\t\t\t\"runtime.wasmExit\": ( sp ) => {\n\t\t\t\t\t\tconst code = mem().getInt32( sp + 8, true );\n\t\t\t\t\t\tthis.exited = true;\n\t\t\t\t\t\tdelete this._inst;\n\t\t\t\t\t\tdelete this._values;\n\t\t\t\t\t\tdelete this._refs;\n\t\t\t\t\t\tthis.exit( code );\n\t\t\t\t\t},\n\n\t\t\t\t\t// func wasmWrite(fd uintptr, p unsafe.Pointer, n int32)\n\t\t\t\t\t\"runtime.wasmWrite\": ( sp ) => {\n\t\t\t\t\t\tconst fd = getInt64( sp + 8 );\n\t\t\t\t\t\tconst p = getInt64( sp + 16 );\n\t\t\t\t\t\tconst n = mem().getInt32( sp + 24, true );\n\t\t\t\t\t\tfs.writeSync( fd, new Uint8Array( this._inst.exports.mem.buffer, p, n ) );\n\t\t\t\t\t},\n\n\t\t\t\t\t// func nanotime() int64\n\t\t\t\t\t\"runtime.nanotime\": ( sp ) => {\n\t\t\t\t\t\tsetInt64( sp + 8, ( timeOrigin + performance.now() ) * 1000000 );\n\t\t\t\t\t},\n\n\t\t\t\t\t// func walltime() (sec int64, nsec int32)\n\t\t\t\t\t\"runtime.walltime\": ( sp ) => {\n\t\t\t\t\t\tconst msec = ( new Date ).getTime();\n\t\t\t\t\t\tsetInt64( sp + 8, msec / 1000 );\n\t\t\t\t\t\tmem().setInt32( sp + 16, ( msec % 1000 ) * 1000000, true );\n\t\t\t\t\t},\n\n\t\t\t\t\t// func scheduleTimeoutEvent(delay int64) int32\n\t\t\t\t\t\"runtime.scheduleTimeoutEvent\": ( sp ) => {\n\t\t\t\t\t\tconst id = this._nextCallbackTimeoutID;\n\t\t\t\t\t\tthis._nextCallbackTimeoutID++;\n\t\t\t\t\t\tthis._scheduledTimeouts.set( id, setTimeout(\n\t\t\t\t\t\t\t() => { this._resume(); },\n\t\t\t\t\t\t\tgetInt64( sp + 8 ) + 1, // setTimeout has been seen to fire up to 1 millisecond early\n\t\t\t\t\t\t) );\n\t\t\t\t\t\tmem().setInt32( sp + 16, id, true );\n\t\t\t\t\t},\n\n\t\t\t\t\t// func clearTimeoutEvent(id int32)\n\t\t\t\t\t\"runtime.clearTimeoutEvent\": ( sp ) => {\n\t\t\t\t\t\tconst id = mem().getInt32( sp + 8, true );\n\t\t\t\t\t\tclearTimeout( this._scheduledTimeouts.get( id ) );\n\t\t\t\t\t\tthis._scheduledTimeouts.delete( id );\n\t\t\t\t\t},\n\n\t\t\t\t\t// func getRandomData(r []byte)\n\t\t\t\t\t\"runtime.getRandomData\": ( sp ) => {\n\t\t\t\t\t\tcrypto.getRandomValues( loadSlice( sp + 8 ) );\n\t\t\t\t\t},\n\n\t\t\t\t\t// func stringVal(value string) ref\n\t\t\t\t\t\"syscall/js.stringVal\": ( sp ) => {\n\t\t\t\t\t\tstoreValue( sp + 24, loadString( sp + 8 ) );\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueGet(v ref, p string) ref\n\t\t\t\t\t\"syscall/js.valueGet\": ( sp ) => {\n\t\t\t\t\t\tconst result = Reflect.get( loadValue( sp + 8 ), loadString( sp + 16 ) );\n\t\t\t\t\t\tsp = this._inst.exports.getsp(); // see comment above\n\t\t\t\t\t\tstoreValue( sp + 32, result );\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueSet(v ref, p string, x ref)\n\t\t\t\t\t\"syscall/js.valueSet\": ( sp ) => {\n\t\t\t\t\t\tReflect.set( loadValue( sp + 8 ), loadString( sp + 16 ), loadValue( sp + 32 ) );\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueIndex(v ref, i int) ref\n\t\t\t\t\t\"syscall/js.valueIndex\": ( sp ) => {\n\t\t\t\t\t\tstoreValue( sp + 24, Reflect.get( loadValue( sp + 8 ), getInt64( sp + 16 ) ) );\n\t\t\t\t\t},\n\n\t\t\t\t\t// valueSetIndex(v ref, i int, x ref)\n\t\t\t\t\t\"syscall/js.valueSetIndex\": ( sp ) => {\n\t\t\t\t\t\tReflect.set( loadValue( sp + 8 ), getInt64( sp + 16 ), loadValue( sp + 24 ) );\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueCall(v ref, m string, args []ref) (ref, bool)\n\t\t\t\t\t\"syscall/js.valueCall\": ( sp ) => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst v = loadValue( sp + 8 );\n\t\t\t\t\t\t\tconst m = Reflect.get( v, loadString( sp + 16 ) );\n\t\t\t\t\t\t\tconst args = loadSliceOfValues( sp + 32 );\n\t\t\t\t\t\t\tconst result = Reflect.apply( m, v, args );\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp(); // see comment above\n\t\t\t\t\t\t\tstoreValue( sp + 56, result );\n\t\t\t\t\t\t\tmem().setUint8( sp + 64, 1 );\n\t\t\t\t\t\t} catch ( err ) {\n\t\t\t\t\t\t\tstoreValue( sp + 56, err );\n\t\t\t\t\t\t\tmem().setUint8( sp + 64, 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueInvoke(v ref, args []ref) (ref, bool)\n\t\t\t\t\t\"syscall/js.valueInvoke\": ( sp ) => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst v = loadValue( sp + 8 );\n\t\t\t\t\t\t\tconst args = loadSliceOfValues( sp + 16 );\n\t\t\t\t\t\t\tconst result = Reflect.apply( v, undefined, args );\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp(); // see comment above\n\t\t\t\t\t\t\tstoreValue( sp + 40, result );\n\t\t\t\t\t\t\tmem().setUint8( sp + 48, 1 );\n\t\t\t\t\t\t} catch ( err ) {\n\t\t\t\t\t\t\tstoreValue( sp + 40, err );\n\t\t\t\t\t\t\tmem().setUint8( sp + 48, 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueNew(v ref, args []ref) (ref, bool)\n\t\t\t\t\t\"syscall/js.valueNew\": ( sp ) => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst v = loadValue( sp + 8 );\n\t\t\t\t\t\t\tconst args = loadSliceOfValues( sp + 16 );\n\t\t\t\t\t\t\tconst result = Reflect.construct( v, args );\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp(); // see comment above\n\t\t\t\t\t\t\tstoreValue( sp + 40, result );\n\t\t\t\t\t\t\tmem().setUint8( sp + 48, 1 );\n\t\t\t\t\t\t} catch ( err ) {\n\t\t\t\t\t\t\tstoreValue( sp + 40, err );\n\t\t\t\t\t\t\tmem().setUint8( sp + 48, 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueLength(v ref) int\n\t\t\t\t\t\"syscall/js.valueLength\": ( sp ) => {\n\t\t\t\t\t\tsetInt64( sp + 16, parseInt( loadValue( sp + 8 ).length ) );\n\t\t\t\t\t},\n\n\t\t\t\t\t// valuePrepareString(v ref) (ref, int)\n\t\t\t\t\t\"syscall/js.valuePrepareString\": ( sp ) => {\n\t\t\t\t\t\tconst str = encoder.encode( String( loadValue( sp + 8 ) ) );\n\t\t\t\t\t\tstoreValue( sp + 16, str );\n\t\t\t\t\t\tsetInt64( sp + 24, str.length );\n\t\t\t\t\t},\n\n\t\t\t\t\t// valueLoadString(v ref, b []byte)\n\t\t\t\t\t\"syscall/js.valueLoadString\": ( sp ) => {\n\t\t\t\t\t\tconst str = loadValue( sp + 8 );\n\t\t\t\t\t\tloadSlice( sp + 16 ).set( str );\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueInstanceOf(v ref, t ref) bool\n\t\t\t\t\t\"syscall/js.valueInstanceOf\": ( sp ) => {\n\t\t\t\t\t\tmem().setUint8( sp + 24, loadValue( sp + 8 ) instanceof loadValue( sp + 16 ) );\n\t\t\t\t\t},\n\n\t\t\t\t\t\"debug\": ( value ) => {\n\t\t\t\t\t\tconsole.log( value );\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tasync run ( instance ) {\n\t\t\tthis._inst = instance;\n\t\t\tthis._values = [ // TODO: garbage collection\n\t\t\t\tNaN,\n\t\t\t\t0,\n\t\t\t\tnull,\n\t\t\t\ttrue,\n\t\t\t\tfalse,\n\t\t\t\tglobal,\n\t\t\t\tthis._inst.exports.mem,\n\t\t\t\tthis,\n\t\t\t];\n\t\t\tthis._refs = new Map();\n\t\t\tthis.exited = false;\n\n\t\t\tconst mem = new DataView( this._inst.exports.mem.buffer )\n\n\t\t\t// Pass command line arguments and environment variables to WebAssembly by writing them to the linear memory.\n\t\t\tlet offset = 4096;\n\n\t\t\tconst strPtr = ( str ) => {\n\t\t\t\tlet ptr = offset;\n\t\t\t\tnew Uint8Array( mem.buffer, offset, str.length + 1 ).set( encoder.encode( str + \"\\0\" ) );\n\t\t\t\toffset += str.length + ( 8 - ( str.length % 8 ) );\n\t\t\t\treturn ptr;\n\t\t\t};\n\n\t\t\tconst argc = this.argv.length;\n\n\t\t\tconst argvPtrs = [];\n\t\t\tthis.argv.forEach( ( arg ) => {\n\t\t\t\targvPtrs.push( strPtr( arg ) );\n\t\t\t} );\n\n\t\t\tconst keys = Object.keys( this.env ).sort();\n\t\t\targvPtrs.push( keys.length );\n\t\t\tkeys.forEach( ( key ) => {\n\t\t\t\targvPtrs.push( strPtr( `${ key }=${ this.env[ key ] }` ) );\n\t\t\t} );\n\n\t\t\tconst argv = offset;\n\t\t\targvPtrs.forEach( ( ptr ) => {\n\t\t\t\tmem.setUint32( offset, ptr, true );\n\t\t\t\tmem.setUint32( offset + 4, 0, true );\n\t\t\t\toffset += 8;\n\t\t\t} );\n\n\t\t\tthis._inst.exports.run( argc, argv );\n\t\t\tif ( this.exited ) {\n\t\t\t\tthis._resolveExitPromise();\n\t\t\t}\n\t\t\tawait this._exitPromise;\n\t\t}\n\n\t\t_resume () {\n\t\t\tif ( this.exited ) {\n\t\t\t\tthrow new Error( \"Go program has already exited\" );\n\t\t\t}\n\t\t\tthis._inst.exports.resume();\n\t\t\tif ( this.exited ) {\n\t\t\t\tthis._resolveExitPromise();\n\t\t\t}\n\t\t}\n\n\t\t_makeFuncWrapper ( id ) {\n\t\t\tconst go = this;\n\t\t\treturn function () {\n\t\t\t\tconst event = { id: id, this: this, args: arguments };\n\t\t\t\tgo._pendingEvent = event;\n\t\t\t\tgo._resume();\n\t\t\t\treturn event.result;\n\t\t\t};\n\t\t}\n\t}\n} )();\n",
    "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\n  <script src=\"https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js\"></script>\n  <link href=\"https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.min.css\" rel=\"stylesheet\">\n</head>\n\n<body>\n  <script>\n    window.pp = 'https://raw.githubusercontent.com/plutoniumm/wassemblers/master/go/';\n  </script>\n  <div id=\"terminal\"></div>\n  <div id=\"code\"></div>\n  <div id=\"output\"></div>\n  <button id=\"compile\">Run</button>\n\n  <style>\n    html,\n    body {\n      margin: 0;\n      padding: 0;\n      max-width: 100vw;\n      overflow-x: hidden;\n    }\n\n    body {\n      background: #222;\n    }\n\n    #compile {\n      display: block;\n      padding: 10px;\n      margin: 10px auto;\n      width: calc(100% - 20px);\n      max-width: 300px;\n      border-radius: 5px;\n      color: #fff;\n      cursor: pointer;\n      background: #334;\n      border: 0;\n      transition: background 0.1s ease-in-out;\n    }\n\n    #compile:hover {\n      background: #223;\n    }\n\n    #compile:disabled {\n      background: #555;\n    }\n\n    .terminal * {\n      background-color: #000 !important;\n    }\n\n    #terminal {\n      max-height: calc(100vh - 2em);\n    }\n  </style>\n\n  <script src=\"./api.js\"></script>\n  <script src=\"./pg.js\"></script>\n  <script src=\"./index.js\"></script>\n</body>\n\n</html>",
    "index.js": "const $ = ( str ) => document.querySelector( str );\n\nlet cmds = {};\nconst exec = ( wasm, args ) => new Promise( ( res, rej ) => {\n  const go = new Go();\n  go.exit = res;\n  go.argv = go.argv.concat( args || [] );\n\n  WebAssembly.instantiate( wasm, go.importObject )\n    .then( r => go.run( r.instance ) );\n} );\n\ntbox.write( \"Getting Ready...\\n\" );\nconst getBuf = ( path ) => fetch( window.pp + path )\n  .then( r => r.arrayBuffer() )\n  .then( b => new Uint8Array( b ) )\n  .catch( ( err ) => log( err ) );\n\nPromise.all( [\n  \"prebuilt/runtime.a\",\n  \"prebuilt/internal/bytealg.a\",\n  \"prebuilt/internal/cpu.a\",\n  \"prebuilt/runtime/internal/atomic.a\",\n  \"prebuilt/runtime/internal/math.a\",\n  \"prebuilt/runtime/internal/sys.a\",\n]\n  .map( ( path ) => getBuf( path ).then( b => writeFS( path, b ) ) )\n  .concat( [ \"compile\", \"link\" ].map( ( cmd ) =>\n    getBuf( \"cmd/\" + cmd + \".wasm\" ).then( b => cmds[ cmd ] = b ),\n  ) ),\n).then( () => {\n  const decoder = new TextDecoder( \"utf-8\" );\n  const encoder = new TextEncoder( \"utf-8\" );\n\n  writeFS(\n    \"/importcfg\",\n    encoder.encode( \"packagefile runtime=prebuilt/runtime.a\" )\n  );\n\n  writeFS(\n    \"/importcfg.link\",\n    encoder.encode(\n      \"packagefile command-line-arguments=main.a\\n\" +\n      \"packagefile runtime=prebuilt/runtime.a\\n\" +\n      \"packagefile internal/bytealg=prebuilt/internal/bytealg.a\\n\" +\n      \"packagefile internal/cpu=prebuilt/internal/cpu.a\\n\" +\n      \"packagefile runtime/internal/atomic=prebuilt/runtime/internal/atomic.a\\n\" +\n      \"packagefile runtime/internal/math=prebuilt/runtime/internal/math.a\\n\" +\n      \"packagefile runtime/internal/sys=prebuilt/runtime/internal/sys.a\",\n    ),\n  )\n  tbox.clear();\n  tbox.write( \"Go Ready!\\n\" );\n\n\n  playground( {\n    codeEl: \"#code\",\n    outputEl: \"#output\",\n    runEl: \"#compile\",\n    transport: {\n      Run: ( body, output ) => {\n        $( \"#compile\" ).setAttribute( \"disabled\", true );\n\n        writeFS( \"/main.go\", body );\n        output( { Kind: \"start\" } );\n        goStderr = ( buf ) => tbox.write( decoder.decode( buf ) );\n        goStdout = ( buf ) => tbox.error( decoder.decode( buf ) );\n\n        exec( cmds[ \"compile\" ], [\n          \"-p\", \"main\", \"-complete\", \"-dwarf=false\",\n          \"-pack\", \"-importcfg\", \"importcfg\", \"main.go\",\n        ] )\n          .then( c => c || exec( cmds[ \"link\" ],\n            [ \"-importcfg\", \"importcfg.link\", \"-buildmode=exe\", \"main.a\" ]\n          ) )\n          .then( c => c || exec( readFS( \"a.out\" ) ) )\n          .then( c => tbox.info( c ? \"status \" + c : \"\" ) )\n          .catch( ( err ) => tbox.error( err.message || '?' ) )\n          .finally( () =>\n            $( \"#compile\" ).removeAttribute( \"disabled\" ),\n          );\n\n        return {\n          Kill: () => { },\n        };\n      },\n    },\n  } );\n\n  $( \"#compile\" ).value = \"Run\";\n  $( \"#compile\" ).removeAttribute( \"disabled\" );\n} );",
    "main.go": "package main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.Handle(\"/\", http.FileServer(http.Dir(\".\")))\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n",
    "pg.js": "\"use strict\";\n\nwindow.proxy_prefix = 'https://raw.githubusercontent.com/plutoniumm/wassemblers/master/cpp/';\n\nconst tbox = new Terminal( {\n  cursorBlink: true,\n  convertEol: true,\n  disableStdin: true,\n} );\nconst term = document.querySelector( '#terminal' );\ntbox.open( term );\ntbox.error = ( str ) => tbox.write( '\\x1b[31m' + str + '\\x1b[0m' );\ntbox.warn = ( str ) => tbox.write( '\\x1b[33m' + str + '\\x1b[0m' );\ntbox.info = ( str ) => tbox.write( '\\x1b[36m' + str + '\\x1b[0m' );\n\nfunction PlaygroundOutput ( el ) {\n  return function ( write ) {\n    if ( write.Kind == \"start\" ) {\n      el.innerHTML = \"\";\n      return;\n    }\n\n    var cl = \"system\";\n    if ( write.Kind == \"stdout\" || write.Kind == \"stderr\" )\n      cl = write.Kind;\n\n    var m = write.Body;\n    if ( write.Kind == \"end\" ) {\n      m = \"\\nProgram exited\" + ( m ? \": \" + m : \".\" );\n    }\n\n    if ( m.indexOf( \"IMAGE:\" ) === 0 ) {\n      // TODO(adg): buffer all writes before creating image\n      var url = \"data:image/png;base64,\" + m.substr( 6 );\n      var img = document.createElement( \"img\" );\n      img.src = url;\n      el.appendChild( img );\n      return;\n    };\n\n    m = m.replace( /&/g, \"&amp;\" );\n    m = m.replace( /</g, \"&lt;\" );\n    m = m.replace( />/g, \"&gt;\" );\n\n    var span = document.createElement( \"span\" );\n    span.className = cl;\n    span.innerHTML = m;\n    el.appendChild( span );\n  };\n}\n\n( function () {\n  const highlightOutput = ( wrapper ) => ( w ) => wrapper( w );\n\n  /*interface Opts {\n    codeEl: string; # code editor element\n    outputEl: string; # program output element\n    runEl: string; # run button element\n    toysEl?: string; # toys select element\n    enableVet?: boolean; # enable running vet and displaying its errors\n  }*/\n  function playground ( opts ) {\n    var transport = opts[ \"transport\" ];\n    var running;\n\n    var outdiv = $( opts.outputEl );\n    outdiv.innerHTML = \"\";\n    var output = document.createElement( \"pre\" );\n    outdiv.appendChild( output );\n\n    const codel = $( opts.codeEl );\n    fetch( '/run.go' ).then( r => r.text() )\n      .then( r => {\n        codel.value = r;\n        codel.style.display = 'none';\n      } );\n\n    function run () {\n      tbox.clear();\n      tbox.write( \"Preparing...\\n\" );\n      if ( running ) running.Kill();\n      tbox.write( \"Running...\\n> \" );\n      running = transport.Run(\n        codel.value,\n        highlightOutput( PlaygroundOutput( output ) ),\n      );\n    }\n    $( opts.runEl ).onclick = run;\n  }\n\n  window.playground = playground;\n} )();",
    "run.go": {
      "active": true,
      "code": "package main\n\nfunc main() {\n\tprintln(\"Hello, WebAssembly playground!\")\n}\n"
    }
  },
  "customSetup": {
    "dependencies": {
      "xterm": "latest"
    }
  }
}