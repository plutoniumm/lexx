[
  {
    "name": "React",
    "value": "react",
    "color": "#5de",
    "type": "template"
  },
  {
    "name": "Preact",
    "value": "vite-preact",
    "color": "#64b",
    "type": "template"
  },
  {
    "name": "Vue",
    "value": "vue",
    "color": "#4b8",
    "type": "template"
  },
  {
    "name": "HTML",
    "value": "static",
    "color": "#f80",
    "type": "template"
  },
  {
    "name": "Solid",
    "value": "solid",
    "color": "#47a",
    "type": "template"
  },
  {
    "name": "C++",
    "color": "#f58",
    "template": "vanilla",
    "value": "cpp",
    "type": "files",
    "files": {
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <script src=\"./index.js\"></script>\n</head>\n\n<body>\n  <div id=\"terminal\"></div>\n  <button id=\"compile\">Compile</button>\n\n  <style>\n    html,\n    body {\n      margin: 0;\n      padding: 0;\n      max-width: 100vw;\n      overflow-x: hidden;\n    }\n\n    body {\n      background: #222;\n    }\n\n    #compile {\n      display: block;\n      padding: 10px;\n      margin: 10px auto;\n      width: calc(100% - 20px);\n      max-width: 300px;\n      border-radius: 5px;\n      color: #fff;\n      cursor: pointer;\n      background: #334;\n      border: 0;\n      transition: background 0.1s ease-in-out;\n    }\n\n    #compile:hover {\n      background: #223;\n    }\n\n    .terminal * {\n      background-color: #000 !important;\n    }\n\n    #terminal {\n      max-height: calc(100vh - 2em);\n    }\n  </style>\n</body>\n\n</html>",
      "index.js": "import { Terminal } from 'xterm';\nimport 'xterm/css/xterm.css';\n\nwindow.proxy_prefix = 'https://raw.githubusercontent.com/plutoniumm/wassemblers/master/cpp/';\n\nconst tbox = new Terminal( {\n  cursorBlink: true,\n  convertEol: true,\n  disableStdin: true,\n} );\nconst term = document.querySelector( '#terminal' );\ntbox.open( term );\ntbox.write( 'Terminal Ready. Compile Now!\\n' );\n\nclass WorkerAPI {\n  constructor () {\n    this.nextResponseId = 0;\n    this.responseCBs = new Map();\n    const channel = new MessageChannel();\n    this.port = channel.port1;\n    this.port.onmessage = this.onmessage.bind( this );\n\n    const remotePort = channel.port2;\n    const remote = window.proxy_prefix + 'worker.js';\n    fetch( remote ).then( res => res.blob() )\n      .then( blob => {\n        this.worker = new Worker( URL.createObjectURL( blob ) );\n        this.worker.postMessage( {\n          id: 'constructor',\n          mod: window.proxy_prefix,\n          data: remotePort\n        }, [ remotePort ] );\n      } );\n  }\n\n  terminate () {\n    this.worker.terminate();\n  }\n\n  async compileToAssembly ( options ) {\n    const responseId = this.nextResponseId++;\n    const responsePromise = new Promise( ( resolve, reject ) => {\n      this.responseCBs.set( responseId, { resolve, reject } );\n    } );\n    this.port.postMessage( {\n      id: 'compileToAssembly',\n      responseId,\n      mod: window.proxy_prefix,\n      data: options\n    } );\n    return await responsePromise;\n  }\n\n  compileLinkRun ( contents ) {\n    this.port.postMessage( {\n      id: 'compileLinkRun',\n      mod: window.proxy_prefix,\n      data: contents\n    } );\n  }\n\n  onmessage ( event ) {\n    switch ( event.data.id ) {\n      case 'write':\n        tbox.write( event.data.data );\n        break;\n\n      case 'compileToAssembly': {\n        const responseId = event.data.responseId;\n        const promise = this.responseCBs.get( responseId );\n        if ( promise ) {\n          this.responseCBs.delete( responseId );\n          promise.resolve( event.data.data );\n        };\n        break;\n      }\n    }\n  }\n};\n\nlet api;\ndocument\n  .querySelector( '#compile' )\n  .addEventListener( 'click', async () => {\n    api = new WorkerAPI();\n    const start = await import( './main.cpp' );\n    api.compileLinkRun( start.default );\n  } );",
      "main.cpp": {
        "active": true,
        "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n  cout << \"Hello, World!\" << endl;\n  return 0;\n}"
      }
    },
    "customSetup": {
      "dependencies": {
        "xterm": "latest"
      }
    }
  },
  {
    "name": "Go",
    "color": "#6ce",
    "template": "static",
    "value": "go",
    "type": "files",
    "files": {
      "api.js": "// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n( () => {\n\tif ( typeof global !== \"undefined\" ) {\n\t\t// global already exists\n\t} else if ( typeof window !== \"undefined\" ) {\n\t\twindow.global = window;\n\t} else if ( typeof self !== \"undefined\" ) {\n\t\tself.global = self;\n\t} else {\n\t\tthrow new Error( \"cannot export Go (neither global, window nor self is defined)\" );\n\t}\n\n\tconst encoder = new TextEncoder( 'utf-8' );\n\tconst decoder = new TextDecoder( 'utf-8' );\n\n\tconst filesystem = {};\n\n\tlet workingDirectory = '/';\n\n\tlet absPath = ( path ) => {\n\t\tif ( path[ 0 ] == '/' ) {\n\t\t\treturn path;\n\t\t}\n\t\treturn workingDirectory + path.replace( /^\\.\\/?/, '' );\n\t};\n\n\tglobal.readFS = ( path ) => filesystem[ absPath( path ) ];\n\tglobal.writeFS = ( path, content ) => {\n\t\tif ( typeof content === 'string' ) {\n\t\t\tfilesystem[ absPath( path ) ] = encoder.encode( content );\n\t\t} else {\n\t\t\tfilesystem[ absPath( path ) ] = content;\n\t\t}\n\t};\n\tglobal.goStdout = ( buf ) => { };\n\tglobal.goStderr = ( buf ) => { };\n\n\tconst openFiles = new Map();\n\tlet nextFd = 1000;\n\n\tlet stat = ( path, callback ) => {\n\t\tlet mode = 0;\n\t\tif ( path === '/' ) {\n\t\t\tmode |= 0x80000000;\n\t\t} else if ( filesystem[ path ] === undefined ) {\n\t\t\tconst err = new Error( 'no such file' );\n\t\t\terr.code = 'ENOENT';\n\t\t\tcallback( err );\n\t\t\treturn;\n\t\t}\n\t\tcallback( null, {\n\t\t\tmode,\n\t\t\tdev: 0,\n\t\t\tino: 0,\n\t\t\tnlink: 0,\n\t\t\tuid: 0,\n\t\t\tgid: 0,\n\t\t\trdev: 0,\n\t\t\tsize: 0,\n\t\t\tblksize: 0,\n\t\t\tblocks: 0,\n\t\t\tatimeMs: 0,\n\t\t\tmtimeMs: 0,\n\t\t\tctimeMs: 0,\n\t\t\tisDirectory: () => !!( mode & 0x80000000 ),\n\t\t} );\n\t};\n\n\tconst constants = {\n\t\tO_WRONLY: 1 << 0,\n\t\tO_RDWR: 1 << 1,\n\t\tO_CREAT: 1 << 2,\n\t\tO_TRUNC: 1 << 3,\n\t\tO_APPEND: 1 << 4,\n\t\tO_EXCL: 1 << 5,\n\t};\n\n\tlet outputBuf = \"\";\n\tglobal.fs = {\n\t\tconstants,\n\t\twriteSync ( fd, buf ) {\n\t\t\tif ( fd === 1 ) {\n\t\t\t\tglobal.goStdout( buf );\n\t\t\t} else if ( fd === 2 ) {\n\t\t\t\tglobal.goStderr( buf );\n\t\t\t} else {\n\t\t\t\tconst file = openFiles[ fd ];\n\t\t\t\tconst source = filesystem[ file.path ];\n\t\t\t\tlet destLength = source.length + buf.length;\n\t\t\t\tif ( file.offset < source.length ) {\n\t\t\t\t\tdestLength = file.offset + buf.length;\n\t\t\t\t\tif ( destLength < source.length ) {\n\t\t\t\t\t\tdestLength = source.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst dest = new Uint8Array( destLength );\n\t\t\t\tfor ( let i = 0;i < source.length;++i ) {\n\t\t\t\t\tdest[ i ] = source[ i ];\n\t\t\t\t}\n\t\t\t\tfor ( let i = 0;i < buf.length;++i ) {\n\t\t\t\t\tdest[ file.offset + i ] = buf[ i ];\n\t\t\t\t}\n\t\t\t\topenFiles[ fd ].offset += buf.length;\n\t\t\t\tfilesystem[ file.path ] = dest;\n\t\t\t}\n\t\t},\n\t\twrite ( fd, buf, offset, length, position, callback ) {\n\t\t\tif ( offset !== 0 || length !== buf.length ) {\n\t\t\t\tthrow new Error( 'write not fully implemented: ' + offset + ', ' + length + '/' + buf.length );\n\t\t\t}\n\t\t\tif ( position !== null ) {\n\t\t\t\topenFiles[ fd ].offset = position;\n\t\t\t}\n\t\t\tthis.writeSync( fd, buf );\n\t\t\tcallback( null, length );\n\t\t},\n\t\topen ( path, flags, mode, callback ) {\n\t\t\t// console.log( 'open(' + path + ', ' + mode + ')' );\n\t\t\tpath = absPath( path );\n\t\t\tif ( !filesystem[ path ] ) {\n\t\t\t\tif ( flags & constants.O_CREAT ) {\n\t\t\t\t\tfilesystem[ path ] = new Uint8Array( 0 );\n\t\t\t\t} else {\n\t\t\t\t\tconst err = new Error( 'no such file' );\n\t\t\t\t\terr.code = 'ENOENT';\n\t\t\t\t\tcallback( err );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( flags & constants.O_TRUNC ) {\n\t\t\t\tfilesystem[ path ] = new Uint8Array( 0 );\n\t\t\t}\n\t\t\tconst fd = nextFd++;\n\t\t\topenFiles[ fd ] = {\n\t\t\t\toffset: 0,\n\t\t\t\tpath,\n\t\t\t};\n\t\t\tcallback( null, fd );\n\t\t},\n\t\tread ( fd, buffer, offset, length, position, callback ) {\n\t\t\tif ( offset !== 0 ) {\n\t\t\t\tthrow new Error( 'read not fully implemented: ' + offset );\n\t\t\t}\n\t\t\tif ( position !== null ) {\n\t\t\t\topenFiles[ fd ].offset = position;\n\t\t\t}\n\t\t\tconst file = openFiles[ fd ];\n\t\t\tconst source = filesystem[ file.path ];\n\t\t\tlet n = length;\n\t\t\tif ( file.offset + length > source.length ) {\n\t\t\t\tn = source.length - file.offset;\n\t\t\t}\n\t\t\tfor ( let i = 0;i < n;++i ) {\n\t\t\t\tbuffer[ i ] = source[ file.offset + i ];\n\t\t\t}\n\t\t\topenFiles[ fd ].offset += n;\n\t\t\tcallback( null, n );\n\t\t},\n\t\tclose ( fd, callback ) {\n\t\t\t// console.log( 'close(' + fd + ')' );\n\t\t\topenFiles.delete( fd );\n\t\t\tcallback( null );\n\t\t},\n\t\tfsync ( fd, callback ) {\n\t\t\tcallback( null );\n\t\t},\n\t\tunlink ( path, callback ) {\n\t\t\t// console.log( 'unlink(' + path + ')' );\n\t\t\tcallback( null );\n\t\t},\n\t\tfstat ( fd, callback ) {\n\t\t\t// console.log( 'fstat(' + fd + ')' );\n\t\t\tstat( openFiles[ fd ].path, callback );\n\t\t},\n\t\tstat ( path, callback ) {\n\t\t\t// console.log( 'stat(' + path + ')' );\n\t\t\tstat( absPath( path ), callback );\n\t\t},\n\t\tlstat ( path, callback ) {\n\t\t\t// console.log( 'lstat(' + path + ')' );\n\t\t\tstat( absPath( path ), callback );\n\t\t},\n\t\tfchmod ( fd, mode, callback ) {\n\t\t\t// console.log( 'fchmod(' + fd + ', ' + mode + ')' );\n\t\t\tcallback( null );\n\t\t},\n\t};\n\n\tglobal.process = {\n\t\tcwd () {\n\t\t\t// console.log( 'cwd()' );\n\t\t\treturn workingDirectory;\n\t\t},\n\t};\n\n\tglobal.Go = class {\n\t\tconstructor () {\n\t\t\tthis.argv = [ \"js\" ];\n\t\t\tthis.env = {};\n\t\t\tthis.exit = ( code ) => {\n\t\t\t\tif ( code !== 0 ) {\n\t\t\t\t\tconsole.warn( \"exit code:\", code );\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._exitPromise = new Promise( ( resolve ) => {\n\t\t\t\tthis._resolveExitPromise = resolve;\n\t\t\t} );\n\t\t\tthis._pendingEvent = null;\n\t\t\tthis._scheduledTimeouts = new Map();\n\t\t\tthis._nextCallbackTimeoutID = 1;\n\n\t\t\tconst mem = () => {\n\t\t\t\t// The buffer may change when requesting more memory.\n\t\t\t\treturn new DataView( this._inst.exports.mem.buffer );\n\t\t\t}\n\n\t\t\tconst setInt64 = ( addr, v ) => {\n\t\t\t\tmem().setUint32( addr + 0, v, true );\n\t\t\t\tmem().setUint32( addr + 4, Math.floor( v / 4294967296 ), true );\n\t\t\t}\n\n\t\t\tconst getInt64 = ( addr ) => {\n\t\t\t\tconst low = mem().getUint32( addr + 0, true );\n\t\t\t\tconst high = mem().getInt32( addr + 4, true );\n\t\t\t\treturn low + high * 4294967296;\n\t\t\t}\n\n\t\t\tconst loadValue = ( addr ) => {\n\t\t\t\tconst f = mem().getFloat64( addr, true );\n\t\t\t\tif ( f === 0 ) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tif ( !isNaN( f ) ) {\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\n\t\t\t\tconst id = mem().getUint32( addr, true );\n\t\t\t\treturn this._values[ id ];\n\t\t\t}\n\n\t\t\tconst storeValue = ( addr, v ) => {\n\t\t\t\tconst nanHead = 0x7FF80000;\n\n\t\t\t\tif ( typeof v === \"number\" ) {\n\t\t\t\t\tif ( isNaN( v ) ) {\n\t\t\t\t\t\tmem().setUint32( addr + 4, nanHead, true );\n\t\t\t\t\t\tmem().setUint32( addr, 0, true );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif ( v === 0 ) {\n\t\t\t\t\t\tmem().setUint32( addr + 4, nanHead, true );\n\t\t\t\t\t\tmem().setUint32( addr, 1, true );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tmem().setFloat64( addr, v, true );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tswitch ( v ) {\n\t\t\t\t\tcase undefined:\n\t\t\t\t\t\tmem().setFloat64( addr, 0, true );\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase null:\n\t\t\t\t\t\tmem().setUint32( addr + 4, nanHead, true );\n\t\t\t\t\t\tmem().setUint32( addr, 2, true );\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase true:\n\t\t\t\t\t\tmem().setUint32( addr + 4, nanHead, true );\n\t\t\t\t\t\tmem().setUint32( addr, 3, true );\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase false:\n\t\t\t\t\t\tmem().setUint32( addr + 4, nanHead, true );\n\t\t\t\t\t\tmem().setUint32( addr, 4, true );\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlet ref = this._refs.get( v );\n\t\t\t\tif ( ref === undefined ) {\n\t\t\t\t\tref = this._values.length;\n\t\t\t\t\tthis._values.push( v );\n\t\t\t\t\tthis._refs.set( v, ref );\n\t\t\t\t}\n\t\t\t\tlet typeFlag = 0;\n\t\t\t\tswitch ( typeof v ) {\n\t\t\t\t\tcase \"string\":\n\t\t\t\t\t\ttypeFlag = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"symbol\":\n\t\t\t\t\t\ttypeFlag = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"function\":\n\t\t\t\t\t\ttypeFlag = 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmem().setUint32( addr + 4, nanHead | typeFlag, true );\n\t\t\t\tmem().setUint32( addr, ref, true );\n\t\t\t}\n\n\t\t\tconst loadSlice = ( addr ) => {\n\t\t\t\tconst array = getInt64( addr + 0 );\n\t\t\t\tconst len = getInt64( addr + 8 );\n\t\t\t\treturn new Uint8Array( this._inst.exports.mem.buffer, array, len );\n\t\t\t}\n\n\t\t\tconst loadSliceOfValues = ( addr ) => {\n\t\t\t\tconst array = getInt64( addr + 0 );\n\t\t\t\tconst len = getInt64( addr + 8 );\n\t\t\t\tconst a = new Array( len );\n\t\t\t\tfor ( let i = 0;i < len;i++ ) {\n\t\t\t\t\ta[ i ] = loadValue( array + i * 8 );\n\t\t\t\t}\n\t\t\t\treturn a;\n\t\t\t}\n\n\t\t\tconst loadString = ( addr ) => {\n\t\t\t\tconst saddr = getInt64( addr + 0 );\n\t\t\t\tconst len = getInt64( addr + 8 );\n\t\t\t\treturn decoder.decode( new DataView( this._inst.exports.mem.buffer, saddr, len ) );\n\t\t\t}\n\n\t\t\tconst timeOrigin = Date.now() - performance.now();\n\t\t\tthis.importObject = {\n\t\t\t\tgo: {\n\t\t\t\t\t// Go's SP does not change as long as no Go code is running. Some operations (e.g. calls, getters and setters)\n\t\t\t\t\t// may synchronously trigger a Go event handler. This makes Go code get executed in the middle of the imported\n\t\t\t\t\t// function. A goroutine can switch to a new stack if the current stack is too small (see morestack function).\n\t\t\t\t\t// This changes the SP, thus we have to update the SP used by the imported function.\n\n\t\t\t\t\t// func wasmExit(code int32)\n\t\t\t\t\t\"runtime.wasmExit\": ( sp ) => {\n\t\t\t\t\t\tconst code = mem().getInt32( sp + 8, true );\n\t\t\t\t\t\tthis.exited = true;\n\t\t\t\t\t\tdelete this._inst;\n\t\t\t\t\t\tdelete this._values;\n\t\t\t\t\t\tdelete this._refs;\n\t\t\t\t\t\tthis.exit( code );\n\t\t\t\t\t},\n\n\t\t\t\t\t// func wasmWrite(fd uintptr, p unsafe.Pointer, n int32)\n\t\t\t\t\t\"runtime.wasmWrite\": ( sp ) => {\n\t\t\t\t\t\tconst fd = getInt64( sp + 8 );\n\t\t\t\t\t\tconst p = getInt64( sp + 16 );\n\t\t\t\t\t\tconst n = mem().getInt32( sp + 24, true );\n\t\t\t\t\t\tfs.writeSync( fd, new Uint8Array( this._inst.exports.mem.buffer, p, n ) );\n\t\t\t\t\t},\n\n\t\t\t\t\t// func nanotime() int64\n\t\t\t\t\t\"runtime.nanotime\": ( sp ) => {\n\t\t\t\t\t\tsetInt64( sp + 8, ( timeOrigin + performance.now() ) * 1000000 );\n\t\t\t\t\t},\n\n\t\t\t\t\t// func walltime() (sec int64, nsec int32)\n\t\t\t\t\t\"runtime.walltime\": ( sp ) => {\n\t\t\t\t\t\tconst msec = ( new Date ).getTime();\n\t\t\t\t\t\tsetInt64( sp + 8, msec / 1000 );\n\t\t\t\t\t\tmem().setInt32( sp + 16, ( msec % 1000 ) * 1000000, true );\n\t\t\t\t\t},\n\n\t\t\t\t\t// func scheduleTimeoutEvent(delay int64) int32\n\t\t\t\t\t\"runtime.scheduleTimeoutEvent\": ( sp ) => {\n\t\t\t\t\t\tconst id = this._nextCallbackTimeoutID;\n\t\t\t\t\t\tthis._nextCallbackTimeoutID++;\n\t\t\t\t\t\tthis._scheduledTimeouts.set( id, setTimeout(\n\t\t\t\t\t\t\t() => { this._resume(); },\n\t\t\t\t\t\t\tgetInt64( sp + 8 ) + 1, // setTimeout has been seen to fire up to 1 millisecond early\n\t\t\t\t\t\t) );\n\t\t\t\t\t\tmem().setInt32( sp + 16, id, true );\n\t\t\t\t\t},\n\n\t\t\t\t\t// func clearTimeoutEvent(id int32)\n\t\t\t\t\t\"runtime.clearTimeoutEvent\": ( sp ) => {\n\t\t\t\t\t\tconst id = mem().getInt32( sp + 8, true );\n\t\t\t\t\t\tclearTimeout( this._scheduledTimeouts.get( id ) );\n\t\t\t\t\t\tthis._scheduledTimeouts.delete( id );\n\t\t\t\t\t},\n\n\t\t\t\t\t// func getRandomData(r []byte)\n\t\t\t\t\t\"runtime.getRandomData\": ( sp ) => {\n\t\t\t\t\t\tcrypto.getRandomValues( loadSlice( sp + 8 ) );\n\t\t\t\t\t},\n\n\t\t\t\t\t// func stringVal(value string) ref\n\t\t\t\t\t\"syscall/js.stringVal\": ( sp ) => {\n\t\t\t\t\t\tstoreValue( sp + 24, loadString( sp + 8 ) );\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueGet(v ref, p string) ref\n\t\t\t\t\t\"syscall/js.valueGet\": ( sp ) => {\n\t\t\t\t\t\tconst result = Reflect.get( loadValue( sp + 8 ), loadString( sp + 16 ) );\n\t\t\t\t\t\tsp = this._inst.exports.getsp(); // see comment above\n\t\t\t\t\t\tstoreValue( sp + 32, result );\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueSet(v ref, p string, x ref)\n\t\t\t\t\t\"syscall/js.valueSet\": ( sp ) => {\n\t\t\t\t\t\tReflect.set( loadValue( sp + 8 ), loadString( sp + 16 ), loadValue( sp + 32 ) );\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueIndex(v ref, i int) ref\n\t\t\t\t\t\"syscall/js.valueIndex\": ( sp ) => {\n\t\t\t\t\t\tstoreValue( sp + 24, Reflect.get( loadValue( sp + 8 ), getInt64( sp + 16 ) ) );\n\t\t\t\t\t},\n\n\t\t\t\t\t// valueSetIndex(v ref, i int, x ref)\n\t\t\t\t\t\"syscall/js.valueSetIndex\": ( sp ) => {\n\t\t\t\t\t\tReflect.set( loadValue( sp + 8 ), getInt64( sp + 16 ), loadValue( sp + 24 ) );\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueCall(v ref, m string, args []ref) (ref, bool)\n\t\t\t\t\t\"syscall/js.valueCall\": ( sp ) => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst v = loadValue( sp + 8 );\n\t\t\t\t\t\t\tconst m = Reflect.get( v, loadString( sp + 16 ) );\n\t\t\t\t\t\t\tconst args = loadSliceOfValues( sp + 32 );\n\t\t\t\t\t\t\tconst result = Reflect.apply( m, v, args );\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp(); // see comment above\n\t\t\t\t\t\t\tstoreValue( sp + 56, result );\n\t\t\t\t\t\t\tmem().setUint8( sp + 64, 1 );\n\t\t\t\t\t\t} catch ( err ) {\n\t\t\t\t\t\t\tstoreValue( sp + 56, err );\n\t\t\t\t\t\t\tmem().setUint8( sp + 64, 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueInvoke(v ref, args []ref) (ref, bool)\n\t\t\t\t\t\"syscall/js.valueInvoke\": ( sp ) => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst v = loadValue( sp + 8 );\n\t\t\t\t\t\t\tconst args = loadSliceOfValues( sp + 16 );\n\t\t\t\t\t\t\tconst result = Reflect.apply( v, undefined, args );\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp(); // see comment above\n\t\t\t\t\t\t\tstoreValue( sp + 40, result );\n\t\t\t\t\t\t\tmem().setUint8( sp + 48, 1 );\n\t\t\t\t\t\t} catch ( err ) {\n\t\t\t\t\t\t\tstoreValue( sp + 40, err );\n\t\t\t\t\t\t\tmem().setUint8( sp + 48, 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueNew(v ref, args []ref) (ref, bool)\n\t\t\t\t\t\"syscall/js.valueNew\": ( sp ) => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst v = loadValue( sp + 8 );\n\t\t\t\t\t\t\tconst args = loadSliceOfValues( sp + 16 );\n\t\t\t\t\t\t\tconst result = Reflect.construct( v, args );\n\t\t\t\t\t\t\tsp = this._inst.exports.getsp(); // see comment above\n\t\t\t\t\t\t\tstoreValue( sp + 40, result );\n\t\t\t\t\t\t\tmem().setUint8( sp + 48, 1 );\n\t\t\t\t\t\t} catch ( err ) {\n\t\t\t\t\t\t\tstoreValue( sp + 40, err );\n\t\t\t\t\t\t\tmem().setUint8( sp + 48, 0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueLength(v ref) int\n\t\t\t\t\t\"syscall/js.valueLength\": ( sp ) => {\n\t\t\t\t\t\tsetInt64( sp + 16, parseInt( loadValue( sp + 8 ).length ) );\n\t\t\t\t\t},\n\n\t\t\t\t\t// valuePrepareString(v ref) (ref, int)\n\t\t\t\t\t\"syscall/js.valuePrepareString\": ( sp ) => {\n\t\t\t\t\t\tconst str = encoder.encode( String( loadValue( sp + 8 ) ) );\n\t\t\t\t\t\tstoreValue( sp + 16, str );\n\t\t\t\t\t\tsetInt64( sp + 24, str.length );\n\t\t\t\t\t},\n\n\t\t\t\t\t// valueLoadString(v ref, b []byte)\n\t\t\t\t\t\"syscall/js.valueLoadString\": ( sp ) => {\n\t\t\t\t\t\tconst str = loadValue( sp + 8 );\n\t\t\t\t\t\tloadSlice( sp + 16 ).set( str );\n\t\t\t\t\t},\n\n\t\t\t\t\t// func valueInstanceOf(v ref, t ref) bool\n\t\t\t\t\t\"syscall/js.valueInstanceOf\": ( sp ) => {\n\t\t\t\t\t\tmem().setUint8( sp + 24, loadValue( sp + 8 ) instanceof loadValue( sp + 16 ) );\n\t\t\t\t\t},\n\n\t\t\t\t\t\"debug\": ( value ) => {\n\t\t\t\t\t\tconsole.log( value );\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tasync run ( instance ) {\n\t\t\tthis._inst = instance;\n\t\t\tthis._values = [ // TODO: garbage collection\n\t\t\t\tNaN,\n\t\t\t\t0,\n\t\t\t\tnull,\n\t\t\t\ttrue,\n\t\t\t\tfalse,\n\t\t\t\tglobal,\n\t\t\t\tthis._inst.exports.mem,\n\t\t\t\tthis,\n\t\t\t];\n\t\t\tthis._refs = new Map();\n\t\t\tthis.exited = false;\n\n\t\t\tconst mem = new DataView( this._inst.exports.mem.buffer )\n\n\t\t\t// Pass command line arguments and environment variables to WebAssembly by writing them to the linear memory.\n\t\t\tlet offset = 4096;\n\n\t\t\tconst strPtr = ( str ) => {\n\t\t\t\tlet ptr = offset;\n\t\t\t\tnew Uint8Array( mem.buffer, offset, str.length + 1 ).set( encoder.encode( str + \"\\0\" ) );\n\t\t\t\toffset += str.length + ( 8 - ( str.length % 8 ) );\n\t\t\t\treturn ptr;\n\t\t\t};\n\n\t\t\tconst argc = this.argv.length;\n\n\t\t\tconst argvPtrs = [];\n\t\t\tthis.argv.forEach( ( arg ) => {\n\t\t\t\targvPtrs.push( strPtr( arg ) );\n\t\t\t} );\n\n\t\t\tconst keys = Object.keys( this.env ).sort();\n\t\t\targvPtrs.push( keys.length );\n\t\t\tkeys.forEach( ( key ) => {\n\t\t\t\targvPtrs.push( strPtr( `${ key }=${ this.env[ key ] }` ) );\n\t\t\t} );\n\n\t\t\tconst argv = offset;\n\t\t\targvPtrs.forEach( ( ptr ) => {\n\t\t\t\tmem.setUint32( offset, ptr, true );\n\t\t\t\tmem.setUint32( offset + 4, 0, true );\n\t\t\t\toffset += 8;\n\t\t\t} );\n\n\t\t\tthis._inst.exports.run( argc, argv );\n\t\t\tif ( this.exited ) {\n\t\t\t\tthis._resolveExitPromise();\n\t\t\t}\n\t\t\tawait this._exitPromise;\n\t\t}\n\n\t\t_resume () {\n\t\t\tif ( this.exited ) {\n\t\t\t\tthrow new Error( \"Go program has already exited\" );\n\t\t\t}\n\t\t\tthis._inst.exports.resume();\n\t\t\tif ( this.exited ) {\n\t\t\t\tthis._resolveExitPromise();\n\t\t\t}\n\t\t}\n\n\t\t_makeFuncWrapper ( id ) {\n\t\t\tconst go = this;\n\t\t\treturn function () {\n\t\t\t\tconst event = { id: id, this: this, args: arguments };\n\t\t\t\tgo._pendingEvent = event;\n\t\t\t\tgo._resume();\n\t\t\t\treturn event.result;\n\t\t\t};\n\t\t}\n\t}\n} )();\n",
      "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\n  <script src=\"https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js\"></script>\n  <link href=\"https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.min.css\" rel=\"stylesheet\">\n</head>\n\n<body>\n  <script>\n    window.pp = 'https://raw.githubusercontent.com/plutoniumm/wassemblers/master/go/';\n  </script>\n  <div id=\"terminal\"></div>\n  <div id=\"code\"></div>\n  <div id=\"output\"></div>\n  <button id=\"compile\">Run</button>\n\n  <style>\n    html,\n    body {\n      margin: 0;\n      padding: 0;\n      max-width: 100vw;\n      overflow-x: hidden;\n    }\n\n    body {\n      background: #222;\n    }\n\n    #compile {\n      display: block;\n      padding: 10px;\n      margin: 10px auto;\n      width: calc(100% - 20px);\n      max-width: 300px;\n      border-radius: 5px;\n      color: #fff;\n      cursor: pointer;\n      background: #334;\n      border: 0;\n      transition: background 0.1s ease-in-out;\n    }\n\n    #compile:hover {\n      background: #223;\n    }\n\n    #compile:disabled {\n      background: #555;\n    }\n\n    .terminal * {\n      background-color: #000 !important;\n    }\n\n    #terminal {\n      max-height: calc(100vh - 2em);\n    }\n  </style>\n\n  <script src=\"./api.js\"></script>\n  <script src=\"./pg.js\"></script>\n  <script src=\"./index.js\"></script>\n</body>\n\n</html>",
      "index.js": "const $ = ( str ) => document.querySelector( str );\n\nlet cmds = {};\nconst exec = ( wasm, args ) => new Promise( ( res, rej ) => {\n  const go = new Go();\n  go.exit = res;\n  go.argv = go.argv.concat( args || [] );\n\n  WebAssembly.instantiate( wasm, go.importObject )\n    .then( r => go.run( r.instance ) );\n} );\n\ntbox.write( \"Getting Ready...\\n\" );\nconst getBuf = ( path ) => fetch( window.pp + path )\n  .then( r => r.arrayBuffer() )\n  .then( b => new Uint8Array( b ) )\n  .catch( ( err ) => log( err ) );\n\nPromise.all( [\n  \"prebuilt/runtime.a\",\n  \"prebuilt/internal/bytealg.a\",\n  \"prebuilt/internal/cpu.a\",\n  \"prebuilt/runtime/internal/atomic.a\",\n  \"prebuilt/runtime/internal/math.a\",\n  \"prebuilt/runtime/internal/sys.a\",\n]\n  .map( ( path ) => getBuf( path ).then( b => writeFS( path, b ) ) )\n  .concat( [ \"compile\", \"link\" ].map( ( cmd ) =>\n    getBuf( \"cmd/\" + cmd + \".wasm\" ).then( b => cmds[ cmd ] = b ),\n  ) ),\n).then( () => {\n  const decoder = new TextDecoder( \"utf-8\" );\n  const encoder = new TextEncoder( \"utf-8\" );\n\n  writeFS(\n    \"/importcfg\",\n    encoder.encode( \"packagefile runtime=prebuilt/runtime.a\" )\n  );\n\n  writeFS(\n    \"/importcfg.link\",\n    encoder.encode(\n      \"packagefile command-line-arguments=main.a\\n\" +\n      \"packagefile runtime=prebuilt/runtime.a\\n\" +\n      \"packagefile internal/bytealg=prebuilt/internal/bytealg.a\\n\" +\n      \"packagefile internal/cpu=prebuilt/internal/cpu.a\\n\" +\n      \"packagefile runtime/internal/atomic=prebuilt/runtime/internal/atomic.a\\n\" +\n      \"packagefile runtime/internal/math=prebuilt/runtime/internal/math.a\\n\" +\n      \"packagefile runtime/internal/sys=prebuilt/runtime/internal/sys.a\",\n    ),\n  )\n  tbox.clear();\n  tbox.write( \"Go Ready!\\n\" );\n\n\n  playground( {\n    codeEl: \"#code\",\n    outputEl: \"#output\",\n    runEl: \"#compile\",\n    transport: {\n      Run: ( body, output ) => {\n        $( \"#compile\" ).setAttribute( \"disabled\", true );\n\n        writeFS( \"/main.go\", body );\n        output( { Kind: \"start\" } );\n        goStderr = ( buf ) => tbox.write( decoder.decode( buf ) );\n        goStdout = ( buf ) => tbox.error( decoder.decode( buf ) );\n\n        exec( cmds[ \"compile\" ], [\n          \"-p\", \"main\", \"-complete\", \"-dwarf=false\",\n          \"-pack\", \"-importcfg\", \"importcfg\", \"main.go\",\n        ] )\n          .then( c => c || exec( cmds[ \"link\" ],\n            [ \"-importcfg\", \"importcfg.link\", \"-buildmode=exe\", \"main.a\" ]\n          ) )\n          .then( c => c || exec( readFS( \"a.out\" ) ) )\n          .then( c => tbox.info( c ? \"status \" + c : \"\" ) )\n          .catch( ( err ) => tbox.error( err.message || '?' ) )\n          .finally( () =>\n            $( \"#compile\" ).removeAttribute( \"disabled\" ),\n          );\n\n        return {\n          Kill: () => { },\n        };\n      },\n    },\n  } );\n\n  $( \"#compile\" ).value = \"Run\";\n  $( \"#compile\" ).removeAttribute( \"disabled\" );\n} );",
      "main.go": "package main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.Handle(\"/\", http.FileServer(http.Dir(\".\")))\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n",
      "pg.js": "\"use strict\";\n\nwindow.proxy_prefix = 'https://raw.githubusercontent.com/plutoniumm/wassemblers/master/cpp/';\n\nconst tbox = new Terminal( {\n  cursorBlink: true,\n  convertEol: true,\n  disableStdin: true,\n} );\nconst term = document.querySelector( '#terminal' );\ntbox.open( term );\ntbox.error = ( str ) => tbox.write( '\\x1b[31m' + str + '\\x1b[0m' );\ntbox.warn = ( str ) => tbox.write( '\\x1b[33m' + str + '\\x1b[0m' );\ntbox.info = ( str ) => tbox.write( '\\x1b[36m' + str + '\\x1b[0m' );\n\nfunction PlaygroundOutput ( el ) {\n  return function ( write ) {\n    if ( write.Kind == \"start\" ) {\n      el.innerHTML = \"\";\n      return;\n    }\n\n    var cl = \"system\";\n    if ( write.Kind == \"stdout\" || write.Kind == \"stderr\" )\n      cl = write.Kind;\n\n    var m = write.Body;\n    if ( write.Kind == \"end\" ) {\n      m = \"\\nProgram exited\" + ( m ? \": \" + m : \".\" );\n    }\n\n    if ( m.indexOf( \"IMAGE:\" ) === 0 ) {\n      // TODO(adg): buffer all writes before creating image\n      var url = \"data:image/png;base64,\" + m.substr( 6 );\n      var img = document.createElement( \"img\" );\n      img.src = url;\n      el.appendChild( img );\n      return;\n    };\n\n    m = m.replace( /&/g, \"&amp;\" );\n    m = m.replace( /</g, \"&lt;\" );\n    m = m.replace( />/g, \"&gt;\" );\n\n    var span = document.createElement( \"span\" );\n    span.className = cl;\n    span.innerHTML = m;\n    el.appendChild( span );\n  };\n}\n\n( function () {\n  const highlightOutput = ( wrapper ) => ( w ) => wrapper( w );\n\n  /*interface Opts {\n    codeEl: string; # code editor element\n    outputEl: string; # program output element\n    runEl: string; # run button element\n    toysEl?: string; # toys select element\n    enableVet?: boolean; # enable running vet and displaying its errors\n  }*/\n  function playground ( opts ) {\n    var transport = opts[ \"transport\" ];\n    var running;\n\n    var outdiv = $( opts.outputEl );\n    outdiv.innerHTML = \"\";\n    var output = document.createElement( \"pre\" );\n    outdiv.appendChild( output );\n\n    const codel = $( opts.codeEl );\n    fetch( '/run.go' ).then( r => r.text() )\n      .then( r => {\n        codel.value = r;\n        codel.style.display = 'none';\n      } );\n\n    function run () {\n      tbox.clear();\n      tbox.write( \"Preparing...\\n\" );\n      if ( running ) running.Kill();\n      tbox.write( \"Running...\\n> \" );\n      running = transport.Run(\n        codel.value,\n        highlightOutput( PlaygroundOutput( output ) ),\n      );\n    }\n    $( opts.runEl ).onclick = run;\n  }\n\n  window.playground = playground;\n} )();",
      "run.go": {
        "active": true,
        "code": "package main\n\nfunc main() {\n\tprintln(\"Hello, WebAssembly playground!\")\n}\n"
      }
    },
    "customSetup": {
      "dependencies": {
        "xterm": "latest"
      }
    }
  },
  {
    "name": "Markdown",
    "color": "#5af",
    "template": "svelte",
    "value": "mdsvex",
    "type": "files",
    "files": {
      "App.svelte": "<script>\n  import render from \"./parse.js\";\n  import content from \"./content.md\";\n\n  function proc(content) {\n    let string = \"\";\n    try {\n      return render(content).html;\n    } catch (e) {\n      console.log(\"ERROR: \", e);\n    }\n\n    return string;\n  }\n</script>\n\n<svelte:head>\n  <link\n    rel=\"stylesheet\"\n    href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css\"\n    crossorigin=\"anonymous\"\n    referrerpolicy=\"no-referrer\"\n  />\n  <link\n    rel=\"stylesheet\"\n    href=\"https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css\"\n    crossorigin=\"anonymous\"\n    referrerpolicy=\"no-referrer\"\n  />\n</svelte:head>\n\n<article>\n  {@html proc(content)}\n</article>\n",
      "content.md": {
        "active": true,
        "code": "---\nproxy: https://x.manav.ch/p2/proxy?url=\ntitle: \"Usage Guide\"\n---\n\n# &title;\n```bash\nmd2html src/content.md\n```\n\n<iframe src=\"https://www.youtube-nocookie.com/embed/dQw4w9WgXcQ\" title=\"Rick Astley - Never Gonna Give You Up (Official Music Video)\" frameborder=\"0\" allow=\"accelerometer; clipboard-write; encrypted-media; picture-in-picture;\"></iframe>\n\n<br />\n\n<img src=\"&proxy;https://www.markdownguide.org/assets/images/markdown-mark.svg\" />\n\n$$\n\\int_{-\\infty}^{\\infty} e^{-x^2} dx !=\n\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & e^{i\\pi} \\\\\n7 & 8 & 9\n\\end{bmatrix}\n$$\n\nThis is a basic example of how to use `md2html` to convert a markdown file to an HTML file.\n\n```html\n<body>\n  <h1>hi</h1>\n</body>\n```\n"
      },
      "parse.js": "import markedKatex from \"marked-katex-extension\";\nimport { markedHighlight } from \"marked-highlight\";\nimport { marked } from \"marked\";\nimport hljs from 'highlight.js';\nimport yaml from \"js-yaml\";\n\nconst renderer = {\n  code ( text, level ) {\n    if ( level === \"mermaid\" ) {\n      return `<pre class=\"mermaid\">${ text }</pre>`;\n    }\n    if ( level === \"psd\" ) {\n      return `<pre class=\"language-ps\">${ text }</pre>`;\n    };\n    return false;\n  }\n};\n\nconst options = {\n  katex: {\n    throwOnError: false,\n    output: \"mathml\",\n  },\n  hljs: {\n    langPrefix: 'hljs language-',\n    highlight ( code, lang ) {\n      if ( lang === \"psd\" ) {\n        const rendered = code\n          .split( \"\\n\" )\n          .map( ( e, i ) => {\n            return `<div class=\"ps\"><m>${ i }:</m>&ensp;${ marked( e, mcf )\n              }</div>`;\n          } )\n          .join( \"\" );\n        return rendered;\n      };\n      const language = hljs.getLanguage( lang ) ? lang : 'plaintext';\n      return hljs.highlight( code, { language } ).value;\n    }\n  }\n}\n\nmarked\n  .use( markedKatex( options.katex ) )\n  .use( markedHighlight( options.hljs ) )\n  .use( { renderer } )\n\nconst mcf = { mangle: false, headerIds: false };\nexport default function render ( text ) {\n  let [ , m, ...rest ] = text.split( \"---\" );\n  m = yaml.load( m?.trim(), { json: true } );\n\n  rest = rest.join( \"---\" )\n  let html = marked( rest, mcf );\n\n  for ( let key in m ) {\n    html = html.replace( `&${ key };`, m[ key ] );\n  }\n  return { meta: m, html }\n};\n",
      "styles.css": "img,\nvideo,\ncode,\npre,\niframe {\n  border-radius: 5px;\n  max-width: 100%;\n}"
    },
    "customSetup": {
      "dependencies": {
        "marked": "latest",
        "js-yaml": "latest",
        "highlight.js": "latest",
        "marked-highlight": "latest",
        "marked-katex-extension": "latest",
        "katex": "latest"
      }
    }
  },
  {
    "name": "Python",
    "color": "linear-gradient(135deg, #57B 0%, #57B 50%, #fd4 50%, #fd4 100%)",
    "template": "static",
    "value": "python",
    "type": "files",
    "files": {
      "index.html": "<html>\n\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n  <link rel=\"stylesheet\" href=\"https://pyscript.net/releases/2024.3.1/core.css\">\n  <script type=\"module\" src=\"https://pyscript.net/releases/2024.3.1/core.js\"></script>\n\n  <script>\n    async function requested ( url, options = {} ) {\n      const res = await fetch( url, options );\n      if ( !res.ok ) {\n        throw new Error( res.statusText );\n      }\n      let contentType = \"application/text\";\n      if ( res.headers ) {\n        contentType = res.headers.get( 'content-type' );\n      };\n      if ( contentType ) {\n        if ( contentType.includes( 'application/json' ) ) {\n          return res.json();\n        } else if ( contentType.includes( 'text/plain' ) ) {\n          return res.text();\n        } else if ( contentType.includes( 'text/html' ) ) {\n          return res.text();\n        } else {\n          return res.blob();\n        }\n      } else {\n        return res.text();\n      }\n    };\n\n    // wrapper to log and return req\n    async function request ( url, options = {} ) {\n      let res = null;\n      try {\n        res = await requested( url, options );\n        console.log( res.slice( 0, 100 ) );\n      } catch ( e ) {\n        console.error( e );\n        res = e;\n      }\n      return res;\n    };\n  </script>\n</head>\n\n<body>\n  <div id=\"term\" style=\"background: #000;color: #fff;font-family: monospace;\">Starting Python...</div>\n\n  <script defer type=\"py\" src=\"./utils.py\" config=\"pyscript.json\"></script>\n  <script defer type=\"py\" src=\"./index.py\" config=\"pyscript.json\"></script>\n\n  <style>\n    #term {\n      min-height: 300px;\n    }\n\n    html,\n    body {\n      width: 100vw;\n      overflow-x: hidden;\n      padding: 0;\n      margin: 0;\n      background: #000;\n    }\n  </style>\n</body>\n\n</html>",
      "index.py": {
        "active": true,
        "code": "from io import StringIO\nimport pandas as pd\n\ndef gh(repo):\n  return f\"https://raw.githubusercontent.com/{repo}\"\n\nasync def main():\n  print(\"Running main script!\")\n  res = await window.request(\n    gh(\"plutoniumm/ifactorial\") + \\\n    \"/main/src/routes/data/R1.csv\"\n  )\n\n  df = pd.read_csv(StringIO(res))\n  print(df.head())\n\nasyncio.create_task(main())"
      },
      "pyscript.json": "{\n  \"packages\": [\n    \"pandas\"\n  ]\n}",
      "utils.py": "from pyscript import document, window\nimport asyncio\n\nout_div = document.querySelector(\"#term\")\nterminal = []\ndef print(*args):\n  terminal.append(\" \".join([str(arg) for arg in args]))\n  out_div.innerText = \"\\n >\".join(terminal)"
    }
  },
  {
    "name": "Svelte",
    "color": "#f40",
    "template": "svelte",
    "value": "sveltevg",
    "type": "files",
    "files": {
      "App.svelte": {
        "active": true,
        "code": "<script></script>\n\n<svg\n  viewBox=\"0 0 100 100\"\n  width=\"100\"\n  height=\"100\"\n  font-family=\"Helvetica\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <defs>\n    <linearGradient id=\"x\" x1=\"0\" y1=\"0\" x2=\"100%\" y2=\"100%\">\n      <stop offset=\"0\" stop-color=\"#b2F\"></stop>\n      <stop offset=\"1\" stop-color=\"#44f\"></stop>\n    </linearGradient>\n    <filter id=\"neo\">\n      <feDropShadow dx=\"0.5\" dy=\"0.5\" stdDeviation=\"0.1\" flood-color=\"#44f\">\n      </feDropShadow>\n      <feDropShadow dx=\"-0.5\" dy=\"-0.5\" stdDeviation=\"0.1\" flood-color=\"#b2F\">\n      </feDropShadow>\n    </filter>\n    <filter id=\"shadow\">\n      <feDropShadow dx=\"2\" dy=\"2\" stdDeviation=\"2\" flood-color=\"#2228\">\n      </feDropShadow>\n    </filter>\n  </defs>\n  <rect\n    filter=\"url(#neo)\"\n    fill=\"url(#x)\"\n    x=\"1\"\n    y=\"1\"\n    width=\"98\"\n    height=\"98\"\n    rx=\"10\"\n  >\n  </rect>\n  <path\n    fill=\"#fff\"\n    filter=\"url(#shadow)\"\n    transform=\"scale(0.15) translate(72.5,85)\"\n    d=\"M380 125l-9-1s-96-7-134 119c-34 110-111 105-115 105h-5a102 102 0 015-204c35 0 67 18 86 47l16-11a122 122 0 10-100 188c17 0 97-6 132-119 33-110 111-105 115-105h7a102 102 0 11-94 157l-16 11a122 122 0 10112-187z\"\n  >\n  </path>\n</svg>\n"
      },
      "styles.css": "svg {\n  width: 500px;\n  height: 500px;\n  border: 1px solid #888;\n}"
    }
  }
]